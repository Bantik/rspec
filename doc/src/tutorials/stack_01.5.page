PLACEHOLDER









So what can we say about the behaviour of an empty stack? The typical first move is to prove that it's really empty by making assertions about its size, or asking it if it is empty. But those things are all about the object's <em><b>state</b></em>, not its behaviour. We want to think about what our Stack does - how it responds to various messages that we can send it. So let's start with the <code>push</code> message. What should an empty Stack do when you send it the push method? Absolutely nothing, right? It should just accept the object and keep its mouth shut:

<ruby>
context "An empty stack" do
  
  specify "should keep its mouth shut when you send it 'push'" do
  end
  
end
</ruby>

Now run that with the <code>spec</code> command (use the -v switch as above) and look at the output. Here's the output:

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push'

Finished in 0.000183 seconds

1 context, 1 specification, 0 failures
</pre>

As you can see, this reads like a specification. This is just like the output you get from running jUnit tests through agiledox. Agiledox was an important part of the inception of BDD, so we built it right into rspec.

Now we haven't really specified anything in code yet, but we have the framework from which to begin - a named context, with a single named specification. So let's make it specify something. Just as in TDD, we want to add things one bit at a time - a little bit of specification, a little bit of code to meet that specification. Slightly departing from TDD, however, we're going to introduce a setup now. Most of the TDD (and xUnit) literature I've read suggests that we should introduce setups to eliminate duplication. In this case, because we're using contexts rather than TestCases, it makes semantic sense to set up the context.

In this case, the context is an empty stack, so let's set one up. 

<ruby>
context "An empty stack" do
  
  setup do
    @stack = Stack.new
  end
  
  specify "should keep its mouth shut when you send it 'push'" do
  end
  
end
</ruby>

...and then run the <code>spec</code> command...

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push' (FAILED - 1)


1)
NameError in 'An empty stack should keep its mouth shut when you send it 'push''
uninitialized constant Stack
./stack_spec.rb:6:in `setup'

Finished in 0.000293 seconds

1 context, 1 specification, 1 failure
</pre>

There are a few things to note about this output.

* "(Failed - 1)" tells you that that particular specification is the one in which a failure occurred.
* "./stack_spec.rb:6:in `setup'" points out that the error was raised in the setup block
* The "1" in "(Failed - 1)" tells you that the stack trace for that failure is the first one.
* 1 context was processed ("An empty stack")
* 1 specification was processed ("should keep its mouth shut when you send it 'push'")
* 1 specification failed ("should keep its mouth shut when you send it 'push'")

The failure <code>uninitialized constant Stack (NameError)</code> tells us that we need to create a Stack class. Add a file to /projects/ruby/stack named stack.rb with the following code:</p>

<ruby>
class Stack
end
</ruby>

Then add this to the top of stack_spec.rb...

<ruby>
require File.dirname(__FILE__) + "/stack"
</ruby>

...and run the <code>spec</code> command and you should see output like this:

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push'


Finished in 0.00022 seconds

1 context, 1 specification, 0 failures
</pre>

We're almost there, but not quite. We still haven't specified what's supposed to happen when we send the push message to the stack. We haven't set any expectations in our specification. We need to have some sort of expectation that, if not met, causes a failure when we execute the spec. So what can we expect here? The name of the spec tells us - "should keep its mouth shut". That implies that it should not react in any way - including raising an error. So let's set the expectation that there will be no error raised:

<ruby>
specify "should keep its mouth shut when you send it 'push'" do
  lambda { @stack.push Object.new }.should.not.raise
end
</ruby>

If you're not familiar, <code>lambda</code> accepts a block but does not execute it. It then constructs a Proc object, which can called at any time. So, in this case, the block <code>{ stack.push Object.new }</code> gets saved in a Proc object. <code>should.not.raise</code> then tells rSpec to call the Proc and raise an ExpectationNotMetError if it raises any errors at all. Running the spec...

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push' (FAILED - 1)


1)
ExpectationNotMetError in 'An empty stack should keep its mouth shut when you send it 'push''
<Proc> should not raise <Exception> but raised #<NoMethodError: undefined method `push' for #<Stack:0x370d94>>
./stack_spec.rb:10:in `should keep its mouth shut when you send it 'push''

Finished in 0.000418 seconds

1 context, 1 specification, 1 failure
</pre> 

The first line tells us the rSpec error that was raised: we were expecting that nothing would be raised, but something (anything) was, so we get an "ExpectationNotMetError".

The second line tells us that we specified that there should be no Exception (in this case we didn't specify what type of exception, so by default rSpec assumes Exception), but that there was a NoMethodError raised.

The third line tells us that the error was raised in the block defining the specification "should keep its mouth shut when you send it 'push'".

We get a NoMethodError because our stack doesn't know what to do with the "push" message. So we add it...

<ruby>
class Stack
  def push item
  end
end
</ruby>

...and run the spec and voila!...

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push'


Finished in 0.000209 seconds

1 context, 1 specification, 0 failures
</pre>

... the code meets the first specification. Now obviously this code doesn't do much, but that's because we have more specifications to write!

One important thing to note here is that we did not begin by setting any expectations about the size or emptiness of the stack. That may feel funny to experienced TDDers, as it is standard faire to verify that an empty collection is empty. As explained in the <a href="index.html">Overview</a>, we're going to explore what it means to specify behaviour rather than testing state. Based on our existing spec thus far, there is no need to have a size or empty method. Let's see how far we can go without them...

<a href="stack_02.html">Next</a>