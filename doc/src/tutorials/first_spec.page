h2. A Simple Stack - The First Specification

h3. Where do we start?

We want to start off with the simplest thing that we can specify, just as we would in TDD. Remember that in spite of some important (if subtle) distinctions, BDD <em>is</em> TDD at its core. Lets start with an empty stack. An empty stack sounds simple, right?

h3. Create a spec file

Start by creating a file called stack_spec.rb in /projects/ruby/stack/. You can use any filename and directory you wish, but the following will assume these names and locations.

h3. Add a context

Add the following to stack_spec.rb

<ruby>
context "An empty stack" do
end
</ruby>

A context represents an object (or set of objects) in a known state. This is the same concept as a fixture in xUnit. For each known state from which we wish to specify behaviour, we'll add a new context.

To see what damage we've done so far, open a command shell, cd to /projects/ruby/stack/, and enter the following:

<pre>
$ spec stack_spec.rb
</pre>

You should see output similar to this

<pre>
Finished in 6.1e-05 seconds

1 context, 0 specifications, 0 failures
</pre>

The <code>spec</code> command is installed when you install rSpec. It requires (using the ruby <code>require</code> method) any file(s) (or all of the files in a directory) that you specify on the command line. The <code>context</code> method accepts a name ("An empty stack") and a block (do ... end) and processes everything inside the block. Since there's nothing in this block to process, we discover that rSpec processed 1 context, but 0 specifications.

You may wonder why bother with the name? Try adding the <code>-v</code> switch to the command

<pre>
$ spec stack_spec.rb -v

An empty stack

Finished in 6.8e-05 seconds

1 context, 0 specifications, 0 failures
</pre>

The <code>-v</code> switch tells rSpec to run in verbose mode, in which case it prints out the names of all the contexts and specifications as they are run. As we progress, you'll see how choosing these names carefully not only documents things well inside the spec files, but also in generated output.

h3. Add a specification

So what can we say about the behaviour of an empty stack? The typical first move is to prove that it's really empty by making assertions about its size, or asking it if it is empty. But those things are all about the object's <em><b>state</b></em>, not its behaviour. We want to think about what our Stack does - how it responds to various messages that we can send it. So let's start with the <code>push</code> message. What should an empty Stack do when you send it the push method? Absolutely nothing, right? It should just accept the object and keep its mouth shut:

<ruby>
context "An empty stack" do
  
  specify "should keep its mouth shut when you send it 'push'" do
  end
  
end
</ruby>

Now run that with the <code>spec</code> command (use the -v switch as above) and look at the output. Here's the output:

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push'

Finished in 0.000183 seconds

1 context, 1 specification, 0 failures
</pre>

As you can see, this reads like a specification. Now we haven't really specified anything in code yet, but we have the framework from which to begin - a named context, with a single named specification. So let's make it specify something. Just as in TDD, we want to add things one bit at a time - a little bit of specification, a little bit of code to meet that specification. Slightly departing from TDD, however, we're going to introduce a setup now. Most of the TDD (and xUnit) literature I've read suggests that we should introduce setups to eliminate duplication. In this case, because we're using contexts rather than TestCases, it makes semantic sense to set up the context.

In this case, the context is an empty stack, so let's set one up. 

<ruby>
context "An empty stack" do
  
  setup do
    @stack = Stack.new
  end
  
  specify "should keep its mouth shut when you send it 'push'" do
  end
  
end
</ruby>

...and then run the <code>spec</code> command...

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push' (FAILED - 1)


1)
./stack_spec.rb:6:in `setup'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/instance_exec.rb:9:in `instance_exec'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/specification.rb:15:in `run'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/context.rb:23:in `run'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/context.rb:22:in `run'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/context_runner.rb:50:in `run_specs'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/context_runner.rb:49:in `run_specs'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/context_runner.rb:41:in `run'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/bin/spec:17
/usr/local/bin/spec:18

Finished in 0.000284 seconds

1 context, 1 specification, 1 failure
</pre>

There are a few things to note about this output.

* "(Failed - 1)" tells you that that particular specification is the one in which a failure occurred.
* The "1" in "(Failed - 1)" tells you that the stack trace for that failure is the first one.
* 1 context was processed ("An empty stack")
* 1 specification was processed ("should keep its mouth shut when you send it 'push'")
* 1 specification failed ("should keep its mouth shut when you send it 'push'")

The failure <code>uninitialized constant Stack (NameError)</code> tells us that we need to create a Stack class. Add a file to /projects/ruby/stack named stack.rb with the following code:</p>

<ruby>
class Stack
end
</ruby>

Then add this to the top of stack_spec.rb...

<ruby>
require File.dirname(__FILE__) + "/stack"
</ruby>

...and run the <code>spec</code> command and you should see output like this:

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push'


Finished in 0.00022 seconds

1 context, 1 specification, 0 failures
</pre>

We're almost there, but not quite. We still haven't specified what's supposed to happen when we send the push message to the stack. We haven't set any expectations in our specification. We need to have some sort of expectation that if not met, causes a failure when we execute the spec. So what can we expect here? The name of the spec tells us - "should keep its mouth shut". That implies that it should not react in any way - including raising an error. So let's set the expectation that there will be no error raised:

<ruby>
specify "should keep its mouth shut when you send it 'push'" do
  lambda { @stack.push Object.new }.should.not.raise
end
</ruby>

If you're not familiar, <code>lambda</code> accepts a block but does not execute it. It then constructs a Proc object, which can called at any time. So, in this case, the block <code>{ stack.push Object.new }</code> gets saved in a Proc object. <code>should.not.raise</code> then tells rSpec to call the Proc and raise an ExpectationNotMetError if it raises any errors at all. Running the spec...

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push' (FAILED - 1)


1)
<Proc> should not raise "#<NoMethodError: undefined method `push' for #<Stack:0x368d4c>>" (Spec::Api::ExpectationNotMetError)
./stack_spec.rb:10:in `should keep its mouth shut when you send it 'push''
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/instance_exec.rb:9:in `instance_exec'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/specification.rb:16:in `run'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/context.rb:23:in `run'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/context.rb:22:in `run'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/context_runner.rb:50:in `run_specs'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/context_runner.rb:49:in `run_specs'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/lib/spec/runner/context_runner.rb:41:in `run'
/usr/local/lib/ruby/gems/1.8/gems/rspec-0.5.4/bin/spec:17
/usr/local/bin/spec:18

Finished in 0.000388 seconds

1 context, 1 specification, 1 failure
</pre> 

We get a NoMethodError because our stack doesn't know what to do with the "push" message. So we add it...

<ruby>
class Stack
  def push item
  end
end
</ruby>

...and run the spec and voila!...

<pre>
$ spec stack_spec.rb -v

An empty stack
- should keep its mouth shut when you send it 'push'


Finished in 0.000209 seconds

1 context, 1 specification, 0 failures
</pre>

... the code meets the first specification. Now obviously this code doesn't do much, but that's because we have more specifications to write!

One important thing to note here is that we did not begin by setting any expectations about the size or emptiness of the stack. That may feel funny to experienced TDDers, as it is standard faire to verify that an empty collection is empty. As explained in the <a href="index.html">Overview</a>, we're going to explore what it means to specify behaviour rather than testing state. Based on our existing spec thus far, there is no need to have a size or empty method. Let's see how far we can go without them...

<a href="second_spec.html">Next</a>
