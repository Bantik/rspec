---
title: Expectation API
---
h2. Expectation API

When RSpec executes specifications, it defines a method <code>should</code> on every object in the system. This <code>should</code> method is your entry to the magic of RSpec.

Almost all expectation forms have a corresponding negated form. It is listed when it is supported and, unless otherwise stated, is met when ever the non-negated form would be violated.

h3. General

h4. Equality and Identity

RSpec delegates equality evaluation directly to ruby's methods and operators

<ruby>
actual.should_equal <value> #passes if actual.equal? <value>
actual.should_not_equal <value> #passes if !actual.equal? <value>

actual.should_eql <value> #passes if actual.eql? <value>
actual.should_not_eql <value> #passes if !actual.eql? <value>

actual.should == <value> #passes if actual == <value>
#there is currently no support for !=, use actual.should_not == instead
</ruby>

h4. Floating Point Comparison

<ruby>
actual.should_be_close <value>, <tolerance>
actual.should_not_be_close <value>, <tolerance>
</ruby>

The actual object is compared to <code>value</code>. If they differ by more that <code>tolerance</code>, <code>ExpectationNotMetError</code> is raised. In the negated case, <code>ExpectationNotMetError</code> is raised if they differ by less than <code>tolerance</code>.

<ruby>
actual.should_be_close 27.35, 0.05
</ruby>

h4. Arbitrary Predicate

<ruby>
actual.should_predicate [optional args]
actual.should_be_predicate [optional args]
actual.should_not_predicate [optional args]
actual.should_not_be_predicate [optional args]
</ruby>

The message <code>predicate?</code> is sent to <code>actual</code> with any supplied arguments. If the result is <code>false</code>, <code>ExpectationNotMetError</code> is raised.

For example:

<ruby>
container.should_include('a') => container.include?('a')
container.should_be_empty => container.empty?
</ruby>

h4. Arbitrary ownership <font color="red">NEW IN 0.7</font>

<ruby>
actual.should_have_<anything> [optional args] 
</ruby>

The message <code>has_<anything>?</code> is sent to <code>actual</code> with any supplied arguments. If the result is <code>false</code>, <code>ExpectationNotMetError</code> is raised.

For example:

<ruby>
hash.should_have_key(:key) => hash.has_key?(:key)
</ruby>

h4. Arbitrary Operators

<ruby>
actual.should_be < value
actual.should_be <= value
actual.should == value
actual.should_be >= value
actual.should_be > vale

actual.should_not == value
</ruby>

The operators are sent to <code>actual</code> with supplied arguments. Note that <code>should !=</code> is not supported, but the same effect can be achieved with <code>should_not ==</code>.

h4. Pattern Matching

<ruby>
actual.should_match <regexp>
actual.should =~ <regexp>
actual.should_not_match <regexp>
</ruby>

The <code>actual</code> is matched against <code>regexp</code>. An <code>ExpectationNotMetError</code> is raised if the match fails.

h3. Class/Type

h4. Direct Instance

<ruby>
actual.should_be_an_instance_of <class>
actual.should_not_be_an_instance_of <class>
</ruby>

An <code>ExpectationNotMetError</code> is raised if <code>actual</code> is not or is, respectively, an direct instance of <code>class</code>. As expected this correlates to <code>actual.instance_of?  class</code>.

h4. Ancestor Class

<ruby>
actual.should_be_a_kind_of <class>
actual.should_not_be_a_kind_of <class>
</ruby>

As above, but uses <code>actual.kind_of? class</code>: checking whether <code>class</code> is the direct class of <code>actual</code>, or an ancestor of <code>actual</code>'s direct class.

h4. Duck Type

<ruby>
actual.should_respond_to <symbol>
actual.should_not_respond_to <symbol>
</ruby>

Uses <code>actual.respond_to?(symbol)</code> to check whether <code>symbol</code> is the name of a message that <code>actual</code> understands.

h3. Procs

h4. Raising

<font color="red">NEW IN 0.7</font>: should_raise will match the message against a regexp

<ruby>
proc.should_raise [<exception>], [<message>|<regexp>]
proc.should_not_raise [<exception>], [<message>|<regexp>]
</ruby>

Checks that <code>proc</code> causes the named exception to be raised or not (possibly with a specific message or regexp to match against the message). The latter is actually one of two cases: some other exception is raised, or no exception is raised. Typically the <code>proc</code> is created in place using <code>lambda</code>. For example:

<ruby>
lambda { 3 / 0 }.should_raise ZeroDivisionError
</ruby>

There is a more general form as well.

<ruby>
proc.should_raise
proc.should_not_raise
</ruby>

These forms don't worry about what exception is raised (or not). All they are concerned with is that some except was raised, or that no exception was.

h4. Throwing

<ruby>
proc.should_throw <symbol>
proc.should_not_throw <symbol>
</ruby>

Similar to the above, but checks that <code>symbol</code> is thrown from within <code>proc</code>, or not. The latter is actually one of two cases: some other symbol is thrown, or no symbol is thrown.

<ruby>
proc.should_not_throw
</ruby>

This form is more specific.  It checks that no symbol is thrown from within <code>proc</code>.

h3. Collections

h4. Containment

<ruby>
actual.should_include <object>
actual.should_not_include <object>
</ruby>

This is simply a specific case of the arbitrary predicate form. It uses <code>actual.include?(object)</code> and raises an <code>ExpectationNotMetError</code> if that returns false. 

h4. Size

The remaining collection forms are a little more involved. They rely on two things:

# <code>actual</code> responds to the message <code>things</code> by returning an object.
# The returned object responds to either <code>length</code> or <code>size</code>, which return a number that is a measure of size. 

Currently <code>length</code> is used if is appropriate, otherwise <code>size</code> is attempted.

h4. Exact Size

<ruby>
actual.should_have(<number>).things
</ruby>

The <code>things</code> of <code>actual</code> has a length/size of exactly <code>number</code>.

h4. Lower Bound

<ruby>
actual.should_have_at_least(<number>).things
</ruby>

The <code>things</code> of <code>actual</code> has a length/size of no less than <code>number</code>.

h4. Upper Bound

<ruby>
actual.should_have_at_most(<number>).things
</ruby>

The <code>things</code> of <code>actual</code> has a length/size of no more than <code>number</code>.

h4. Arbitrary Block

<ruby>
actual.should_satisfy {|arg| ...}
actual.should_not_satisfy {|arg| ...}
</ruby>

The supplied block is evaluated, passing <code>actual</code> as the sole argument. If the block evaluates to <code>false</code>, <code>ExpectationNotMetError</code> is raised.

<ruby>
actual.should_satisfy {|arg| arg > 0}
</ruby>

