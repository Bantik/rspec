---
title: Contexts
---
h2. Contexts and Specifications

Rather than expressing examples in classes, RSpec uses a custom domain specific language to express
examples using contexts and specifications.

A context is the equivalent of a fixture in xUnit-speak. It is a metaphor for the context
in which you will run your executable example - a set of known objects in a known starting state.

<ruby>
context "A new account" do

  setup do
    @account = Account.new
  end

  specify "should have a balance of $0" do
    @account.balance.should_eql Money.new(0, :dollars)
  end

end
</ruby>

We use the setup block to set up the context (given), and then the specify method to
hold the example code that expresses the event (when) and the expected outcome (then).

h3. Helper Methods

A primary goal of RSpec is to keep the examples clear. We therefore prefer
less indirection than you might see in xUnit examples and in well factored, DRY production code. We feel
that duplication is OK if removing it makes it harder to understand an example without
having to look elsewhere to understand its context.

That said, RSpec does support some level of encapsulating common code in helper
methods that can exist within a context or within an included module.

h4. Setup and Teardown

You can use setup, teardown, context_setup and context_teardown within a context:

<ruby>
context "..." do
  context_setup do
    ...
  end

  setup do
    ...
  end

  specify "number one" do
    ...
  end

  specify "number two" do
    ...
  end

  teardown do
    ...
  end

  context_teardown do
    ...
  end
  
end
</ruby>

The <code>setup</code> block will run before each of the specs, once for each spec. Likewise,
the <code>teardown</code> block will run after each of the specs.

It is also possible to specify a <code>context_setup</code> and <code>context_teardown</code>
block that will run only once for each context, respectively before the first <code>setup</code>
and after the last <code>teardown</code>. The use of these is generally discouraged, because it
introduces dependencies between the specs. Still, it might prove useful for very expensive operations
if you know what you are doing.

h4. Local helper methods

You can include local helper methods by simply expressing them within a context:

<ruby>
context "..." do

  specify "..." do
    helper_method
  end
  
  def helper_method
    ...
  end

end
</ruby>

h4. Included helper methods

You can include helper methods in multiple contexts by expressing them within
a module, and then including that module in your context:

<ruby>
module AccountExampleHelperMethods
  def helper_method
    ...
  end
end

context "A new account" do
  include AccountExampleHelperMethods
  setup do
    @account = Account.new
  end

  specify "should have a balance of $0" do
    helper_method
    @account.balance.should_eql Money.new(0, :dollars)
  end
end
</ruby>