---
title: Core API
inMenu: true
ordering: 5
---
h2. Core API

When RSpec executes specifications, it defines a method *should* on every object in the system.
This *should* method is your entry to the magic of RSpec.

Almost all expectation forms have a corresponding negated form. It is listed
when it is supported and, in general, is met when ever the non negated form would be
violated.

h3. General

h4. Arbitrary Block

<pre>
<code>
target.should.satisfy {|arg| ...}
target.should.not.satisfy {|arg| ...}
</code>
</pre>

The supplied block is evaluated, passing _target_ as the sole argument. If the
block evaluates to _false_ in the case of _should.satisfy_, or _true_ in the case of
_should.not.satisfy_, _ExpectationNotMetError_ is raised.

<pre>
<code>
target.should.satisfy {|arg| arg > 0}
</code>
</pre>

h4. Equality

<pre>
<code>
target.should.equal <value>
target.should.not.equal <value>
</code>
</pre>

The target object is compared to _value_ using ==. If the result is _false_ (or
_true_ for the negated form) _ExpectationNotMetError_ is raised.

h4. Floating Point Comparison

<pre>
<code>
target.should.be.close <value>, <tolerance>
target.should.not.be.close <value>, <tolerance>
</code>
</pre>

The target object is compared to _value_. In the former case, if they differ
by more that _tolerance_ _ExpectationNotMetError_ is raised. In the latter case,
it is raised if they differ by less than _tolerance_.

<pre>
<code>
target.should.be.close 27.35, 0.05
</code>
</pre>

h4. Identity

<pre>
<code>
target.should.be <value>
target.should.not.be <value>
</code>
</pre>

The target object is compared to _value_ using _equal?_. If the result is _false_
(or _true_ for the negated form) _ExpectationNotMetError_ is raised.

h4. Arbitrary Predicate


<pre>
<code>
target.should.predicate [optional args]
target.should.be.predicate [optional args]
target.should.not.predicate [optional args]
target.should.not.be.predicate [optional args]
</code>
</pre>

The message _predicate?_ is sent to _target_ with any supplied arguments. If the
result is _false_ (or _true_ for the negated form) _ExpectationNotMetError_ is
raised.

<pre>
<code>
container.should.include 'a' => container.include? 'a'
container.should.be.empty => container.empty?
</code>
</pre>

h4. Pattern Matching

<pre>
<code>
target.should.match <regex>
target.should.not.match <regex>
</code>
</pre>

The _target_ is matched against _regex_. An _ExpectationNotMetError_ is raised if
the match fails or succeeds, respectively.

h3. Class/Type

h4. Direct Instance

<pre>
<code>
target.should.be.an.instance.of <class>
target.should.not.be.an.instance.of <class>
</code>
</pre>

An _ExpectationNotMetError_ is raised if _target_ is not or is, respectively, an
direct instance of _class_. As expected this correlates to _target.instance_of?
 class_.

h4. Ancestor Class

<pre>
<code>
target.should.be.a.kind.of <class>
target.should.not.be.a.kind.of <class>
</code>
</pre>

As above, but uses _target.kind_of? class_: checking whether _class_ is the
direct class of _target_, or an ancestor of _target_'s class.

h4. Type

<pre>
<code>
target.should.respond.to <symbol>
target.should.not.respond.to <symbol>
</code>
</pre>

Uses _target.respond_to? symbol?_ to check whether _symbol_ is the name of a
message that _target_ understands.

h3. Procs

h4. Raising

<pre>
<code>
proc.should.raise <exception>
proc.should.not.raise <exception>
</code>
</pre>

Checks that _proc_ does or doesn't cause the named exception to be raised.
Typically the _proc_ is created in place using _lambda_. For example:

<pre>
<code>
lambda { 3 / 0 }.should.raise ZeroDivisionError
</code>
</pre>

There is a more general form as well.

<pre>
<code>
proc.should.raise
proc.should.not.raise
</code>
</pre>

These forms don't worry about what exception is raised (or not). All they are
concern with is that some except was raised, or that no exception was raised.

h4. Throwing

<pre>
<code>
proc.should.throw <symbol>
proc.should.not.throw <symbol>
</code>
</pre>

Similar to the above, but checks that _symbol_ is thrown from within _proc_, or
that it is not. The latter is actually one of two cases: some other symbol is
thrown, or no symbol is thrown.

<pre>
<code>
proc.should.not.throw
</code>
</pre>

This form is more specific.  It checks that no symbol is thrown from within _proc_.

h3. Collections

h4. Containment

<pre>
<code>
target.should.include <object>
</code>
</pre>

This is simply a specific case of the arbitrary predicate form. It uses
_target.include? object_ and raises an _ExpectationNotMetError_ if that returns
false. The remaining collection forms are a little more involved. They rely on
two things: _target_ responds to the message _things_ by returning an object
that responds to either _length_ or _size_, which return a number that is a
measure of size. Currently _length_ is used if is appropriate, otherwise _size_ is
attempted.

h4. Exact Size

<pre>
<code>
target.should.have(<number>).<things>
</code>
</pre>

The _things_ of _target_ has a length/size of exactly _number_. 

h4. Lower Bound

<pre>
<code>
target.should.have.at.least(<number>).<things>
</code>
</pre>

The _things_ of _target_ has a length/size of no less than _number_.

h4. Upper Bound

<pre>
<code>
target.should.have.at.most(<number>).<things>
</code>
</pre>

The _things_ of _target_ has a length/size of no more than _number_.
