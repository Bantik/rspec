h2. A Simple Stack

h3. Choosing the next Specification

We left our code in a state in which it could not be refactored because adding conditional logic would be adding new behaviour at this point (which is not refactoring). We wanted to refactor because we had a hard-coded return value from a method that is begging for some conditional logic. So let's choose a specification to focus on next that will help us to address that. We want a specification that will result in a non-empty stack.

Since an "empty stack" seems more interesting from a behavioural perspective than a "new stack", let's start talking about the behaviour of an <em>empty</em> stack.

<ruby>
context "An empty stack" do
  specify "should not be empty after 'push'" do
  end
end
</ruby>

<pre>
$ spec stack_spec.rb -f s

A new stack
- should be empty

An empty stack
- should not be empty after 'push'

Finished in 0.00105 seconds

2 specifications, 0 failures
</pre>

See how that's reading like a specification? OK, now let's fill in the details. First we add the setup for our context.

<ruby>
context "An empty stack" do
  setup do
    @stack = Stack.new
  end
  specify "should not be empty after 'push'" do
  end
end
</ruby>

<pre>
$ spec stack_spec.rb -f s

A new stack
- should be empty

An empty stack
- should not be empty after 'push'

Finished in 0.001 seconds

2 specifications, 0 failures
</pre>

No change in the result. Now we'll push something on to the stack.

<ruby>
context "An empty stack" do
  setup do
    @stack = Stack.new
  end
  specify "should not be empty after 'push'" do
    @stack.push 37
  end
end
</ruby>

<pre>
$ spec stack_spec.rb -f s

A new stack
- should be empty

An empty stack
- should not be empty after 'push' (FAILED - 1)

1)
NoMethodError in 'An empty stack should not be empty after 'push''
undefined method `push' for #<Stack:0x5b4c68>
./stack_spec.rb:17:in `should not be empty after 'push''

Finished in 0.001254 seconds

2 specifications, 1 failure
</pre>

The <code>NoMethodError</code> tells us we need to add a push method to the stack.

<ruby>
class Stack
  def empty?
    true
  end
  def push item
  end
end
</ruby>

<pre>
$ spec stack_spec.rb -f s

A new stack
- should be empty

An empty stack
- should not be empty after 'push'

Finished in 0.001082 seconds

2 specifications, 0 failures
</pre>

The idea is to add a little bit of spec, just enough to get some kind of failure, then just enough code to get the code to meet the expectations expressed in the spec. In this case, the NameError was like a compilation failure in java or C#.

Next we set our expectation:

<ruby>
context "An empty stack" do
  setup do
    @stack = Stack.new
  end
  specify "should not be empty after 'push'" do
    @stack.push 37
    @stack.should_not_be_empty
  end
end
</ruby>

<pre>
$ spec stack_spec.rb -f s

A new stack
- should be empty

An empty stack
- should not be empty after 'push' (FAILED - 1)

1)
Spec::Expectations::ExpectationNotMetError in 'An empty stack should not be empty after 'push''
Stack #<Stack:0x5b4b00> should not be empty
./stack_spec.rb:18:in `should not be empty after 'push''

Finished in 0.001454 seconds

2 specifications, 1 failure
</pre>

The <code>ExpectationNotMetError</code> tells us we have something to implement. We want to do the simplest thing that we can do to meet our existing expectations. At this point we don't know anything about collections or even specific values, so we can just manage whether or not it is empty.

<ruby>
class Stack
  def initialize
    @empty = true
  end
  def empty?
    @empty
  end
  def push item
    @empty = false
  end
end
</ruby>

<pre>
$ spec stack_spec.rb -f s

A new stack
- should be empty

An empty stack
- should not be empty after 'push'

Finished in 0.001077 seconds

2 specifications, 0 failures
</pre>

Again, this may seem a little odd, but we haven't specified anything yet about what happens to things that get pushed on to the stack. We want to write the simplest code that will meet the existing expectations. Again, the fact that we haven't needed to implement any sort of collection is a deficiency in our examples, not in the code being specified.

<a href="stack_01.html">Previous</a> |
<a href="stack_03.html">Next</a>