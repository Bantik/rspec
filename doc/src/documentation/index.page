---
title: Executable Examples
---
h2. Executable Examples

RSpec provides a Domain Specific Language with which you can express executable
examples of the expected behaviour of a system.

Imagine that you were talking to a customer requesting software for her bank.
Part of that conversation might well look like this:

<pre>
You:      Describe an account when it is first created.
Customer: It should have a balance of $0.
</pre>

Here's how we express that conversation in RSpec:

<ruby>describe Account, " when first created" do
  it "should have a balance of $0" do
    ...
  end
end
</ruby>

When you execute this example, RSpec can provide a report like this:

<pre>
Account, when first created
- should have a balance of $0
</pre>

So we use RSpec to <code>#describe</code> <b>Behaviour</b> of a system using <b>Examples</b>
of how <code>#it</code> should work.

h2. A Bit More Detail

Here's how the example might look with some more code filled in:

<ruby>describe Account, " when first created" do

  before do
    @account = Account.new
  end

  it "should have a balance of $0" do
    @account.balance.should eql(Money.new(0, :dollars))
  end
  
  after do
    @account = nil
  end

end
</ruby>

The <code>#describe</code> method returns a <code>Behaviour</code> object, which represents
a particular behaviour of the system that you wish to describe. Technically,
a <code>Behaviour</code> is the equivalent of a fixture in xUnit-speak. It
is a metaphor for the context in which you will execute your example - a set of
known objects in a known starting state.

The <code>#it</code> method returns an <code>Example</code> object, which represents
an example of the behaviour your are trying to describe.

The <code>#before</code> and <code>#after</code> methods are just
like <code>#setup</code> and <code>#teardown</code> in xUnit. You use them to
set up the state _before_ each example is executed, and tear down any
resources _after_ each example.

h4. #before and #after

You can use <code>#before</code> and/or <code>#after</code> to define
code that executes before and after each example or only once per Behaviour:

<ruby>describe Thing do
  before(:all) do
    # This is run once and only once, before all of the examples
    # and before any before(:each) blocks.
  end

  before(:each) do
    # This is run before each example.
  end

  before do
    # :each is the default, so this is the same as before(:each)
  end

  it "should do stuff" do
    ...
  end

  it "should do more stuff" do
    ...
  end

  after(:each) do
    # this is before each example
  end
  
  after do
    # :each is the default, so this is the same as after(:each)
  end

  after(:all) do
    # this is run once and only once after all of the examples
    # and after any after(:each) blocks
  end
  
end
</ruby>

<b>Warning</b>: The use of <code>#before(:all)</code> and <code>#after(:all)</code> is
generally discouraged because it introduces dependencies between the Examples.
Still, it might prove useful for very expensive operations if you know what you are doing.

h4. Helper Methods

You can write helper methods directly within a Behaviour:

<ruby>describe "..." do

  specify "..." do
    helper_method
  end
  
  def helper_method
    ...
  end

end
</ruby>

h4. Reusable Helper Methods

You can include helper methods in multiple Behaviours by expressing them within
a module, and then including that module in your Behaviour:

<ruby>module AccountExampleHelperMethods
  def helper_method
    ...
  end
end

describe "A new account" do
  include AccountExampleHelperMethods
  setup do
    @account = Account.new
  end

  it "should have a balance of $0" do
    helper_method
    @account.balance.should eql(Money.new(0, :dollars))
  end
end
</ruby>