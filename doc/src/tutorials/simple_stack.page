---
title: A Simple Stack
---

h2. A Simple Stack

h3. A simple (very much in progress) tutorial by David Chelimsky

One of the examples we use at Object Mentor in our TDD classes is test-driving a Stack. We usually start with this test (though it's usually in java):

<pre>
#NOT A BDD EXAMPLE
def test_new_stack_should_be_empty
  stack = Stack.new
  assert_equal(0, stack.size)
end
</pre>

We start with that because it is a VERY simple place to start. Fine. So here's a question: what is the <em><b>behaviour</b></em> that is exhibited by <code>size</code>? You <em>could</em> argue that the behaviour is that it answers your question correctly, but is that really behaviour?

Think of it this way: does size really matter? Keeping focused on the Stack example, I'd say the answer is often "no". Most clients probably care about whether they can push on to the stack, or pop off of it. But knowing whether it has 0 or 1000 items is only helpful if the client knows what those numbers mean. Perhaps the spec suggests that an empty Stack should return nil on pop or peek.

If you want to push, and you query the size, how do you know what capacity is? You don't care if the stack has n elements. The real question is "do have room for one more thing?"

Additionally, <code>size</code> violates the "Tell, Don't Ask" rule. So do any of the questions above (empty?, full?, etc), but size is particularly problematic because you have to ask more questions to understand the meaning of the answer to that question.

This is something else I've been exploring quite a bit. We talk about "Tell, Don't Ask" all the time, yet I see properties being exposed all over the place in code written by some very smart people. Why is that? I think that the code example above is part of the reason. TDD tells us to write the simplest thing we can test first. Create a new Stack, verify that it has no elements. Easy! Right? Except that YAGNI except for that test.

I'm going to explore these questions in this tutorial in addition to getting you started with rSpec.

h3. Getting Started

