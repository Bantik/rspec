---
title: Mock API
inMenu: true
---
h2. Mock API

RSpec contains a full featured Mock Objects framework.

h3. Creating a mock

<ruby>
mock(<name>)
</ruby>

This creates a new mock with the given name (a string) and registers it. When the specification finishes, all registered mocks are verified.

<ruby>
mock(<name>, <options>)
</ruby>

As above, but allows you to specific options to tweak the mock's behaviour. The <code>options</code> argument is a hash. Currently the only supported option is <code>:null_object</code>. Setting this to true (i.e. <code>:null_object => true</code>) instructs the mock to ignore (quietly consume) any messages it hasn't been told to expect.

h3. Expecting Messages

<ruby>
mock.should.receive(<message>)
</ruby>

The <code>message</code> argument is a symbol that is the name of a message that you want
the mock to be expecting.

h3. Arbitrary Message Receive Handling

You can supply a block to a message expectation. When the message is received
by the mock, the block is evaluated, and passed any arguments. The result is
the return value of the message. For example:

<ruby>
@mock.should.receive(:random_call) {| a | a.should.be true}
</ruby>

This allows arbitrary argument validation and result computation.

h3. Expecting Arguments

<ruby>
mock.should.receive(:msg).with(<args>)
mock.should.receive(:msg).with(1, 2, 3)
</ruby>

The <code>args</code> argument is a series of arguments (e..g. 1, 2, 3) that are expected
to be passed as arguments to the associated message.

<ruby>
mock.should.receive(:msg).with(:no_args)
</ruby>

No arguments are to be accepted by the message.

<ruby>
mock.should.receive(:msg).with(:any_args)
</ruby>

Any arguments are to be accepted by the message. This includes cases where no
arguments are provided. *This is the default when no <code>with()</code> clause is
specified.*  Even so, sometimes you want to be explicit about it.

h3. Argument Constraints

Constraints can be placed on individual arguments which are looser than value equivalence.

h4. :anything

accepts any value for this argument

<ruby>
mock.should.receive(:msg).with(1, :anything, "A")
</ruby>

h4. :numeric

accepts any numeric value for this argument

<ruby>
mock.should.receive(:msg).with(a, :numeric, "b")
</ruby>

h4. :boolean

accepts a boolean value for this argument

<ruby>
mock.should.receive(:msg).with(a, :boolean, "b")
</ruby>

h4. :string

accepts any string for this argument

<ruby>
mock.should.receive(:msg).with(a, :string, "b")
</ruby>
	
h4. duck_type(message(s))

accepts any object that responds to the prescribed message(s)

<ruby>
#accepts a Fixnum for the second arg
mock.should.receive(:msg).with(a, duck_type(:abs, :div), "b") 
</ruby>

h3. Receive Counts

<ruby>
mock.should.receive(:msg).never
</ruby>

A problem is reported if the message is ever received.

<ruby>
mock.should.receive(:msg).any.number.of.times
</ruby>

The message can be received 0 or more times.

<ruby>
mock.should.receive(:msg).once
</ruby>

A problem is reported is the message is never received, or it is received more
than once.

<ruby>
mock.should.receive(:msg).twice
</ruby>

A problem is reported is the message is received anything but two times.

<ruby>
mock.should.receive(:msg).exactly(n).times
</ruby>

A problem is reported is the message is received anything but n times.

<ruby>
mock.should.receive(:msg).at.least(:once)
</ruby>

A problem is reported if the message is never received.

<ruby>
mock.should.receive(:msg).at.least(:twice)
</ruby>

A problem is reported is the message is never received or is received only once.

<ruby>
mock.should.receive(:msg).at.least(n).times
</ruby>

A problem is reported is the message is received fewer than n times.

h3. Return Values

<ruby>
mock.should.receive(:msg).once.and.return(<value>)
</ruby>

When the expected message is received, <code>value</code> will be returned as the result.

<ruby>
and.return([<value-1>, <value-2>, ..., <value-n>])
</ruby>

When the expected message is received, <code>value-i</code> will be returned as the result
for the ith reception of the message. Once <code>i > n</code>, <code>value-n</code> is returned for all
subsequent receives of the message.

<ruby>
mock.should.receive(:msg).once.and.return {...} 
</ruby>

When the expected message is received, the result of evaluating the supplied
block will be returned as the result. The block is passed any arguments passed
as parts of the message. This capability can be used to compute return values
based on the arguments.  For example:

<ruby>
mock.should.receive(:msg).once.and.return {|a, b| a + b}
</ruby>

h3. Raising and Throwing

<ruby>
mock.should.receive(:msg).once.and.raise(<exception>)
mock.should.receive(:msg).once.and.throw(<symbol>) 
</ruby>

These instruct the mock to raise an exception or throw a symbol instead of returning a value.

h3. Yielding

<ruby>
mock.should.receive(:msg).once.and.yield([<value-1>, <value-2>, ..., <value-n>])
</ruby>

When the expected message is received, the mock will yield the values to the passed block.

h3. Ordering

There are times when you want to specify the order of messages sent to a mock.
It shouldn't be the case very often, but it can be handy at time. 

Labeling expectations as being ordered is done by the <code>ordered</code> call:

<ruby>
mock.should.receive(:flip).once.ordered
mock.should.receive(:flop).once.ordered
</ruby>

If the send of <code>flop</code> is seen before <code>flip</code> the specification will fail.

Of course, chains of ordered expectations can be set up:

<ruby>
@mock.should.receive(:one).ordered
@mock.should.receive(:two).ordered
@mock.should.receive(:three).ordered
</ruby>

Order-independant expectations can be set anywhere in the expectation sequence, in any order.  
Only the order of expectation tagged with the <code>ordered</code> call is significant.  Likewise,
calls to order-independant methods can be made in any order, even interspersed with calls to 
order-dependant methods.  For example:

<ruby>
def test_two_ordered_calls_with_others_between
  @mock.should.receive(:zero)
  @mock.should.receive(:one).ordered
  @mock.should.receive(:two).ordered
  @mock.should.receive(:one_and_a_half)
  @mock.one
  @mock.one_and_a_half
  @mock.zero
  @mock.two
  @mock.__verify
end
</ruby>